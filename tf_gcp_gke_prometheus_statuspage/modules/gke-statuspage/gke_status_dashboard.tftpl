# ---------------------------------------------------------------------------
# GKE STATUSPAGE DASHBOARD TEMPLATE
#
# This template is rendered by Terraform via templatefile().
#
# INPUT VARIABLES (provided by Terraform):
#   - env_name      : environment ID (e.g. "ft1")
#   - env_ns        : Kubernetes namespace for this environment (e.g. "x-ft1")
#   - env_cluster   : cluster name label in Prometheus (e.g. "x-gke-ft1")
#   - cuj_workloads : map of:
#         cuj_id = {
#           name      = "customer-success"
#           workloads = ["service1", "service2"]
#         }
#
# LAYOUT LOGIC SUMMARY:
#   - Dashboard uses a Mosaic layout: 12 columns wide.
#   - Each CUJ gets a vertical "band" of height 30 units.
#   - The CUJ header sits at the top of that band: yPos = cuj_index * 30
#   - Each service tile is 8x8 units and stacked vertically under the CUJ header.
#     Example:
#         CUJ header: y=0..2
#         service 1: y=2..10
#         service 2: y=10..18
#         service 3: y=18..26
#   - Tiles are centered horizontally (xPos = 2, width = 8).
# ---------------------------------------------------------------------------

${jsonencode({

  # Dashboard title
  displayName = "GKE Service Status - ${env_cluster} - ${env_name}"

  # Dashboard labels for filtering/searching in Cloud Monitoring
  labels = {
    env     = env_name
    cluster = env_cluster
    type    = "statuspage"
    ns      = env_ns
  }

  # Pinned filter at the top of the GCP dashboard
  # This forces all queries to be filtered by the selected namespace.
  dashboardFilters = [
    {
      labelKey         = "namespace"
      filterType       = "METRIC_LABEL"
      templateVariable = "namespace"
      stringValue      = env_ns
    }
  ]

  mosaicLayout = {
    # Total number of columns in the grid
    columns = 12

    # The full list of tiles (headers + services), built dynamically
    tiles = flatten([

      # Iterate each CUJ (ordered by map keys)
      for cuj_index, cuj_id in keys(cuj_workloads) : [

        # -------------------------------------------------------------------
        # CUJ HEADER TILE
        # -------------------------------------------------------------------
        {
          # Full width (12 columns)
          xPos   = 0
          # Each CUJ gets its own "vertical band" of size 30
          yPos   = cuj_index * 30
          width  = 12
          height = 2

          widget = {
            title = "CUJ: ${cuj_id} - ${cuj_workloads[cuj_id].name} (${env_name})"

            text = {
              format  = "MARKDOWN"
              content = "### ${cuj_id} - ${cuj_workloads[cuj_id].name} (${env_name})\nNamespace: `${env_ns}`\nCluster: `${env_cluster}`\nStatus of workloads in this critical user journey."
            }
          }
        },

        # -------------------------------------------------------------------
        # SERVICE TILES (8×8 scorecards)
        #
        # - width  = 8 columns
        # - xPos   = 2 → centered (columns 2 to 9)
        # - height = 8 rows
        # - yPos   = CUJ header offset + service index * 8
        #
        # Example for svc_index=0:
        #     y = (cuj_index * 30) + 2
        # Example for svc_index=1:
        #     y = (cuj_index * 30) + 2 + 8
        # -------------------------------------------------------------------
        for svc_index, svc in cuj_workloads[cuj_id].workloads : {
          xPos   = 2
          yPos   = cuj_index * 30 + 2 + svc_index * 8
          width  = 8
          height = 8

          widget = {
            title = "Service: ${svc} (${cuj_id} ${cuj_workloads[cuj_id].name}, env: ${env_name})"

            scorecard = {

              # -------------------------------------------------------------------
              # PROMQL QUERY for health:
              #
              # min_over_time(up{...}[5m])
              #   - `up` is 1 when the target is healthy and being scraped by Prometheus
              #   - `min_over_time()` ensures that any failure in the last 5 minutes -> 0
              #   - Result:
              #         1.0 = healthy (always up)
              #         0.0 = unhealthy (down at least once)
              #
              # Adjust label names if your Prometheus schema differs.
              # -------------------------------------------------------------------
              timeSeriesQuery = {
                prometheusQuery = "min_over_time(up{job=\"kubernetes-pods\", cluster=\"${env_cluster}\", namespace=\"${env_ns}\", workload=\"${svc}\"}[5m])"
              }

              # Render as gauge (0 to 1)
              gaugeView = {
                lowerBound = 0
                upperBound = 1
              }

              # Mark tile red when health < 0.5
              thresholds = [
                {
                  label     = "Down"
                  value     = 0.5
                  color     = "RED"
                  direction = "BELOW"
                }
              ]
            }
          }
        }
      ]
    ])
  }
})}